# .cursorrules

> **Purpose:**  
> This file is the authoritative rulebook for Vibe.  
> It defines architecture, coding standards, and workflow rules.  
> For detailed explanations, see the referenced guides.

---

## Rule Precedence
1. **Always-applied workspace rules** (auto-injected by infrastructure)
2. **Repo-specific master rule** â€“ this `.cursorrules` file
3. **Topic rules** in `.cursor/rules/*.mdc` (architecture, testing, probes, etc.)
4. **Mode rules** (Architect mode, Agent mode) set at runtime

Lower-level rules may clarify but **must not conflict** with higher-level ones.  When in doubt, the higher entry wins.

---

**1. Project Architecture & File Structure**

- Vibe uses a strict modular architecture.
- Do NOT reference or use legacy/monolithic files.
- All new code must be modular, focused, and placed in the correct file.

**Current Modular Files (as of 2024):**
- Core Systems: `GameLoop.js`, `GameState.js`, `CameraSystem.js`, `SpawnSystem.js`, `CollisionSystem.js`, `UIRenderer.js`, `BackgroundRenderer.js`, `TestMode.js`
- Entities: `player.js`, `BaseEnemy.js`, `Grunt.js`, `Rusher.js`, `Tank.js`, `Stabber.js`, `EnemyFactory.js`, `bullet.js`
- Support: `Audio.js`, `BeatClock.js`, `visualEffects.js`, `effects.js`, `config.js`, `mathUtils.js`
- Other: `ticketManager.js`, `ai-liveness-probe.js`
- (See `/js/` for the full, up-to-date list. For details, see README.md.)

**Legacy Files (Do NOT use):**
- `js/game.js` (replaced by `GameLoop.js`)
- `js/enemy.js` (replaced by `BaseEnemy.js` + individual enemy classes)
- `js/explosion.js` (replaced by `packages/fx/src/effects.js` + `packages/fx/src/visualEffects.js`)
- `js/explosions/*` (fully superseded by modular explosion classes under `packages/fx/src/explosions/`)

- Never suggest or implement monolithic or legacy patterns.
- Update this section and the README.md if the architecture changes.

---

**2. Ticketing System: Bugs, Features, Enhancements, Tasks**

- All ticket operations must use the shared `TicketCore` library via the REST API server.
  - The primary interface is the `ticket-api.js` server (thin wrapper around **`packages/api/src/TicketRouter.js` + `TicketService.js`**).
  - Browser-based tools like `packages/tooling/src/ticketManager.js` act as clients to this API.
  - The CLI tools have been removed.
- If the API is down, manually inspect JSON files in tests/bug-reports/. See the troubleshooting/manual workflow section in TICKETING_SYSTEM_GUIDE.md for details.

ğŸš€ Ticketing system API Quick Reference:

- **List Tickets:** `GET /api/tickets`
- **Create Ticket:** `POST /api/tickets`
- **Get Ticket:** `GET /api/tickets/:id`
- **Update Ticket:** `PATCH /api/tickets/:id`
- **Delete Ticket:** `DELETE /api/tickets/:id`

- The ticketing system is a core, modular subsystem.
- All work (bugs, features, enhancements, tasks) must be tracked via the ticketing system API.
- Full documentation, schema, API usage, and workflow best practices are now in the dedicated guide:
  - â¡ï¸ **See [`TICKETING_SYSTEM_GUIDE.md`](./TICKETING_SYSTEM_GUIDE.md) for all details.**
- Tickets are structured JSON files stored in `tests/bug-reports/`.
- Use the provided API endpoints (`ticket-api.js`) and JS modules (`packages/tooling/src/ticketManager.js`) for all ticket management (in-game, admin, automation).
- Each ticket **must** include:
  - `id` â€“ unique identifier (API rejects duplicates)
  - `type` â€“ `bug`, `feature`, `enhancement`, or `task`
  - `title` â€“ concise human-readable summary (â‰¤ 60 chars)
  - `slug` â€“ kebab-case URL slug (auto-derived if omitted)

Recommended optional fields: `tags` (`focus`, `regression`, `needs-design`, etc.), `artifacts`, `history`.

- The bug-report watcher script (`move-bug-reports.js`) auto-moves artifacts to the correct folder.
- The AI must be able to programmatically open the bug-report modal and access the same data as a human tester.
- All feature/enhancement work should be logged through the same metadata-rich JSON ticket workflow.
- **Known issue:** If the bug report modal does not close after submission, this is tracked as bug ticket `BR-2024-06-01-modal-bug-001`. See the guide for troubleshooting steps.

---

**3. MCP Tools Usage Guide (Summary)**

**What are MCP Tools?**
- MCP tools are advanced, server-powered utilities for memory management, Playwright testing, and file operations.
- Use them for tasks that require more power, precision, or automation than built-in Cursor tools.

**Categories & When to Use:**

- **Memory Management**
  - Use for: Reading, updating, and organizing the project's knowledge graph.
  - Key tools: `mcp_memory_read_graph`, `mcp_memory_search_nodes`, `mcp_memory_add_observations`, etc.
  - Path: N/A (entity-based, not file-based)

- **Playwright Testing**
  - Use for: Automated, probe-driven browser testing, bug reproduction, and artifact capture.
  - Key tools: `mcp_playwright_navigate`, `mcp_playwright_click`, `mcp_playwright_press_key`, etc.
  - Path: N/A (browser automation)

- **Filesystem Operations**
  - Use for: Batch file reads, precise line edits, directory management, and metadata.
  - Key tools: `mcp_filesystem_read_file`, `mcp_filesystem_edit_file`, `mcp_filesystem_list_directory`, etc.
  - Path: **Absolute paths required** (e.g., `D:\projects\vibe\...`)

**Best Practices:**
- Prefer built-in tools for simple, day-to-day edits.
- Use MCP tools for batch, advanced, or automation tasks.
- Always check path requirements (absolute for MCP filesystem, relative for built-in).
- For advanced Playwright workflows, see [MCP_PLAYWRIGHT_TESTING_GUIDE.md](./MCP_PLAYWRIGHT_TESTING_GUIDE.md).

**Example: Automated Bug Ticket Creation**
1. Run probe-driven test with MCP Playwright.
2. On failure, capture screenshot and logs.
3. Use `packages/tooling/src/ticketManager.js` and `ticket-api.js` to create a new bug ticket with artifacts.
4. Artifacts are auto-moved to the correct folder by `move-bug-reports.js`.

---

**Workflow Note: Robust Server Startup**
- The `predev` script kills any process on ports 5500 and 3001 before starting dev servers.
- The `dev` script starts Five Server (frontend), bug watcher, and ticket API server in parallel.
- If port 5500 is in use, Five Server will use another port (e.g., 56555); always check the console for the actual port.
- **Preferred Environment:** Windows 11 + PowerShell 7 + Bun for optimal performance and Windows-native tooling.

**Shell and Path Standards (MANDATORY):**
- **ALWAYS use PowerShell 7 (pwsh) as the default shell** - NOT bash, WSL, or cmd
- **ALWAYS use Windows-style paths** (e.g., `D:\projects\vibe`) - NOT Unix-style paths (`/c/...`)
- **ALWAYS use `bun` and `bunx`** instead of `npm` and `npx`
- **Terminal commands must work in PowerShell** - avoid bash-specific syntax
- **File paths in scripts must use Windows format** with backslashes or forward slashes that work in PowerShell
- If terminal shows `/c/...` paths, navigate to proper Windows path: `Set-Location "D:\projects\vibe"`
- **Ensure only ONE Bun install**: use the official installer at `%USERPROFILE%\.bun\bin`; remove Scoop/npm/Homebrew copies to avoid CLI timeouts.

---

**4. Memory Management**

- The project uses a structured knowledge graph for entities, relations, and observations.
- **Entity:** A meaningful component or concept (e.g., Player, Enemy, Bullet, BeatClock, Audio).
- **Relation:** A directed connection describing interaction or dependency (e.g., Player *fires* Bullet).
- **Observation:** A concise, factual note about an entity or relation (e.g., "`Bullet.js` handles velocity and collision detection.").

**Guidelines:**
- Keep memory focused and cleanâ€”avoid information overload.
- Quality over quantity: Fewer, well-organized entities.
- Focus on the current state; archive resolved issues.
- Regularly clean up outdated or redundant information.

**Entity Organization:**
- Max 10-15 observations per entityâ€”split if exceeding.
- One clear responsibility per entity; use meaningful names.
- Avoid duplicatesâ€”search before creating new entities.

**Good Examples:**  
- `VibeGame` (project overview), `GameArchitecture`, `CosmicBeatSystem`, `AudioSystem`, `TestingSystem`

**Anti-Patterns to Avoid:**  
- Version-specific or temporary entities, issue-tracking entities, information overload, inconsistent naming.

**Workflow:**
1. Read memory first: `mcp_memory_read_graph`
2. Search existing: `mcp_memory_search_nodes`
3. Open specific: `mcp_memory_open_nodes`
4. Plan changes, update existing entities, add current state observations, create relations, and note key decisions.
5. Archive resolved issues, update current state, clean up temporary observations, and verify relations.

---

**5. Coding Standards**

- **MCP File Edit Workflow (MANDATORY):**  
  All `mcp_filesystem_edit_file` operations must follow this workflow:  
  1. ALWAYS use `dryRun: true` first and review the diff carefully  
  2. Only proceed with `dryRun: false` if diff matches expectations  
  3. Before real edit, back up the file if it's critical  
  4. After editing, immediately validate the file's content  
  5. If corrupted or missing expected content, restore from backup  
  6. Optionally, run a linter for code/config files  
  7. Delete backup if edit is successful

- **Simplicity:** Write simple, straightforward code.
- **Readability:** Code should be easy to read and understand.
- **Performance:** Optimize only when it doesn't harm readability.
- **Maintainability:** Code should be easy to update and maintain.
- **Testability:** Code should be easy to test.
- **Reusability:** Write reusable components and functions.

**Rules:**
- Only modify code related to the task at handâ€”minimal changes.
- Use early returns to avoid nested conditions.
- Prefer conditional classes over ternary operators for class attributes.
- Use descriptive names for variables and functions. Prefix event handlers with "handle" (e.g., handleClick).
- Use constants instead of functions where possible.
- Write correct, DRY (Don't Repeat Yourself) code.
- Prefer functional, immutable style unless much more verbose.
- Add a comment at the start of each function describing what it does.
- Use JSDoc comments for JavaScript (unless TypeScript).
- Order functions so that those composing others appear earlier in the file.
- If you encounter a bug or suboptimal code, add a `// TODO:` comment outlining the problem.
- All code must pass linting (ESLint) and formatting (Prettier) checks before commit. See README for setup.
- **ESLint Configuration:** Use `bunx eslint . --ext .js` for Windows compatibility instead of glob patterns
- **Linting Commands:** `bun run lint` (check), `bun run lint:fix` (auto-fix), both work in PowerShell
- Use ES modules (`import`/`export`) for all new code unless otherwise specified.
- Handle errors gracefully and consistently; use early returns and clear error messages.
- Write code that is easy to test (favor pure functions, dependency injection where possible).
- Manage dependencies via `package.json` and Bun; do not add libraries without team review.

**Dependency Injection & Global Access:**
- Prefer constructor injection for dependencies (e.g., audio, cameraSystem) in new modules
- Allow window.* access for shared game systems that need global coordination
- Core systems (gameState, audio, beatClock, player) may use window.* for cross-module communication
- Entity-specific data should use dependency injection where practical
- Do not attach game state or systems to the p5 instance (`p`). Only use `p` for p5-native methods and properties.
- This hybrid approach balances modularity with practical game development needs.

**Architecture Validation:**
- New systems must receive dependencies via constructor injection where practical
- Files >500 lines should consider splitting by responsibility
- Console.log usage: Include emoji prefixes for categorization (ğŸ® for game state, ğŸµ for audio, etc.)
- Each module should have a clear, single primary responsibility
- Update memory knowledge graph when adding new systems or major changes

**Timing Standards:**
- Use deltaTimeMs for time-based calculations (movement, animations)
- Use frame counters only for simple state machines or fixed-duration effects
- Normalize to 60fps baseline: `const dt = deltaTimeMs / 16.6667`
- BeatClock system takes precedence for musical timing coordination

**Strict Consistency Standards (Multi-AI Model Compatibility):**

- **Constructor Standards (MANDATORY):**
  - All enemy classes MUST use exact signature: `constructor(x, y, type, config, p, audio)`
  - âœ… Correct: `super(x, y, 'stabber', config, p, audio)` 
  - âŒ Incorrect: `super(x, y, 'stabber', config)` // Missing dependencies
  - ğŸ¯ Rationale: Ensures dependency injection consistency across AI models

- **Import/Export Standards:**
  - ALWAYS import math functions from mathUtils.js instead of using p5 globals
  - âœ… Correct: `import { sin, cos, random } from './mathUtils.js'`
  - âŒ Incorrect: `sin(angle)` // Using p5 global
  - ğŸ¯ Rationale: Explicit imports make dependencies clear and testable

- **Error Handling Standards:**
  - Pattern 1 (Preferred): `if (typeof obj !== 'undefined' && obj) { obj.method(); }`
  - Pattern 2 (External): `try { external.api(); } catch(e) { console.log('âš ï¸ API Error:', e); }`
  - âŒ Never: `obj.method()` // No safety checks
  - ğŸ¯ Rationale: Consistent error handling prevents runtime crashes

- **Method Signature Standards:**
  - ALL enemy methods MUST accept deltaTimeMs parameter
  - âœ… Correct: `update(playerX, playerY, deltaTimeMs = 16.6667)`
  - âœ… Correct: `updateSpecificBehavior(playerX, playerY, deltaTimeMs)`
  - âŒ Incorrect: `update(playerX, playerY)` // Missing deltaTimeMs
  - ğŸ¯ Rationale: Frame-independent timing requires consistent parameter passing

- **Console Logging Standards (ENFORCED):**
  - ALL logs MUST use emoji prefixes for categorization
  - âœ… Correct: `console.log('ğŸ® Game state changed:', newState)`
  - âœ… Correct: `console.log('ğŸ—¡ï¸ Stabber attacking at distance:', distance)`
  - âŒ Incorrect: `console.log('Stabber attacking')` // No emoji
  - Emoji map: ğŸ® Game state, ğŸµ Audio, ğŸ—¡ï¸ Combat, ğŸ’¥ Explosions, âš ï¸ Errors, ğŸš€ Movement, ğŸ¯ AI behavior, ğŸ›¡ï¸ Defense, ğŸ¥ Health
  - ğŸ¯ Rationale: Consistent logging helps debugging across different developers/AI models

- **Return Value Standards:**
  - Methods that can hit targets MUST return structured objects:
  - âœ… Correct: `return { type: 'stabber-melee', playerHit: true, damage: 25 }`
  - âŒ Incorrect: `return true` // Ambiguous
  - Null/undefined for no-action cases: `return null`
  - ğŸ¯ Rationale: Structured returns enable GameLoop.js to handle all cases consistently

- **Global Access Hierarchy (CLARIFIED):**
  - Tier 1 (window.*): gameState, audio, beatClock, player (core coordination)
  - Tier 2 (injection): p5 instance, cameraSystem, specific systems
  - Tier 3 (forbidden): Internal enemy state, temporary calculations
  - âœ… Correct: `window.audio.playSound()` // Core system
  - âœ… Correct: `this.audio.playSound()` // If injected
  - âŒ Incorrect: `window.someTemporaryVariable` // Not core system
  - ğŸ¯ Rationale: Clear hierarchy prevents globals abuse while allowing necessary coordination

  **Event-bus requirement:** Whenever the Player instance is created or recreated, code must execute:

  ```javascript
  window.dispatchEvent(new CustomEvent('playerChanged', { detail: window.player }));
  ```

  This keeps Audio and other listening systems synchronized with the live player. Missing the dispatch is considered a breaking violation.

- **p5.js Instance Mode Standards (MANDATORY):**
  - ALL drawing functions MUST use `this.p.` or `p.` prefix in instance mode
  - âœ… Correct: `this.p.fill(255, 0, 0)`, `this.p.ellipse(x, y, w, h)`, `this.p.textAlign(this.p.CENTER)`
  - âŒ Incorrect: `fill(255, 0, 0)`, `ellipse(x, y, w, h)`, `textAlign(CENTER)` // Missing prefix
  - ğŸ¯ Rationale: Prevents global namespace pollution and ensures instance mode compatibility across all AI models

- **Math Function Import Standards (MANDATORY):**
  - ALWAYS import math functions from mathUtils.js instead of using p5 globals
  - âœ… Correct: `import { sin, cos, random, sqrt, atan2, min, max } from './mathUtils.js'`
  - âŒ Incorrect: `sin(angle)`, `random(0, 100)`, `sqrt(x*x + y*y)` // Using p5 globals
  - ğŸ¯ Rationale: Explicit imports make dependencies clear, enable testing, and prevent p5 version conflicts

- **Attack Method Return Standards (MANDATORY):**
  - ALL attack methods MUST return structured objects or null
  - âœ… Correct: `return { type: 'melee', playerHit: true, damage: 25, x: this.x, y: this.y }`
  - âœ… Correct: `return null` // No action taken
  - âŒ Incorrect: `return true`, `return false` // Ambiguous boolean returns
  - ğŸ¯ Rationale: Structured returns enable GameLoop.js to handle all attack types consistently across AI models

- **Sound Effects Safety: All SFX names MUST be defined in `packages/core/src/audio/SoundIds.js` (`SOUND` registry) and have matching configs in `Audio.sounds`. The build will throw if mismatch.**

_See the dedicated consistency specification: [AR-consistency-standards.mdc](mdc:.cursor/rules/AR-consistency-standards.mdc) for constructor signatures, emoji logging map, p5 instance-mode rules, and other strict norms._

---

**6. Testing & Playwright**

- **Probe-driven testing only:** Manual Playwright `.spec.js` tests are **prohibited**.  Keep **probe** files only (suffix `*-probe.test.js`).  Delete or archive any remaining `.spec.js` tests.
- **Use MCP Playwright for all automated tests.**
- **Preferred automated test entry:** `bun run test:orchestrated` (starts Five-Server + Ticket-API, waits for health checks, runs Playwright + MCP probes deterministically).
- **Dev server runs on port 5500** (`http://localhost:5500`).
- **Game must be started before gameplay checks** (restart from game-over if needed).
- **Activate audio:** Click canvas at (400,300) to enable audio context.
- **Test mode:** Press 'T' key for scripted testing mode.
- **Bug report automation:** On probe failure, auto-capture screenshot and logs, restart and retry, then create a detailed bug report if the issue persists.
- **Artifacts:** All screenshots and logs must be saved in the correct bug-report folder, auto-moved by `move-bug-reports.js`.
- **Keyboard shortcuts:** In the bug-report modal, Enter/Ctrl+Enter = Save, Escape = Cancel.
- **AI must be able to open the bug-report modal programmatically and access the same data as a human tester.**

*See linked rule file for the full probe workflow and debugging details.*

_For the full automated-testing workflow (probe conventions, dev server setup, ticket automation), see [AR-testing-and-debugging.mdc](mdc:.cursor/rules/AR-testing-and-debugging.mdc)._

---

**7. Error Handling & Fallbacks**

- **Common Issues & Solutions:**
  - *File not found:* Check current architecture, avoid legacy files.
  - *Playwright clicks fail:* Use canvas coordinates or JavaScript evaluation.
  - *Audio context issues:* Ensure user interaction before audio.
  - *Memory errors:* Check entity names exist before creating relations.
  - *Build errors:* Run terminal commands to check dependencies.

- **Fallback Strategies:**
  - If semantic search fails â†’ try grep search with exact terms.
  - If Playwright fails â†’ use test mode (T key) for automation.
  - If file edit fails â†’ try reapply tool for better accuracy.
  - If memory search is empty â†’ read the full graph to understand structure.

---

**8. Future Expansion & MCP Tools Documentation**

- For advanced MCP tool usage, troubleshooting, and workflow examples, see [MCP_TOOLS_GUIDE.md](./MCP_TOOLS_GUIDE.md).
- This file will provide:
  - Deeper explanations of each MCP tool category
  - Example commands and workflows
  - Troubleshooting tips and advanced usage
  - References to other guides (e.g., `MCP_PLAYWRIGHT_TESTING_GUIDE.md`)
- **Keep this `.cursorrules` file focused on core rules, standards, and best practices.**

---

**9. p5.js Usage**

- If a JavaScript file uses p5.js global functions (e.g., `constrain()`, `random()`, `lerp()`), add a top-of-file comment:
  `// Requires p5.js for constrain(), random(), lerp(), etc.`
- The project uses p5.js version 1.7.0. (See package.json and README.)
- In instance mode: use `p.` prefix for all p5 functions and constants (e.g., `p.TWO_PI`, `p.constrain()`)
- Import commonly used constants via mathUtils.js when possible for consistency

---

**10. HTML & CSS Standards**

- Use semantic HTML elements and follow accessibility (a11y) best practices.
- Organize CSS for modularity and maintainability (e.g., BEM, CSS modules, or utility classes).
- Place custom scripts and styles in dedicated files unless otherwise specified.
- Ensure all UI is keyboard accessible and screen-reader friendly.
- Reference the README for any framework-specific or build tool requirements.

---

**Event-Bus VFX System Rules**
- All new visual effects must use the event-bus pattern (emit events via EnemyEventBus, never call visualEffectsManager directly from entities).
- VFXDispatcher is the only module that translates gameplay events into visual/screen effects.
- All VFX must be testable via Playwright probes.
- Update effectsConfig.js for all balancing and tuning.

---

**11. Security & Secrets**

_See [AR-security.mdc](mdc:.cursor/rules/AR-security.mdc) for the authoritative security & secrets policy._

---

**End of File**