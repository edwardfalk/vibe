# .cursorrules

> **Purpose:**  
> This file is the authoritative rulebook for Vibe.  
> It defines architecture, coding standards, and workflow rules.  
> For detailed explanations, see the referenced guides.

---

## Rule Precedence
1. **Always-applied workspace rules** (auto-injected by infrastructure)
2. **Repo-specific master rule** – this `.cursorrules` file
3. **Topic rules** in `.cursor/rules/*.mdc` (architecture, testing, probes, etc.)
4. **Mode rules** (Architect mode, Agent mode) set at runtime

Lower-level rules may clarify but **must not conflict** with higher-level ones.  When in doubt, the higher entry wins.

---

**1. Project Architecture & File Structure**

- Vibe uses a strict modular architecture.
- Do NOT reference or use legacy/monolithic files.
- All new code must be modular, focused, and placed in the correct file.

**Current Modular Architecture (Fully Migrated):**
- **Core Systems:** `packages/systems/` - GameLoop, GameState, CameraSystem, SpawnSystem, CollisionSystem, UIRenderer, BackgroundRenderer, TestMode, etc.
- **Entities:** `packages/entities/` - player, BaseEnemy, Grunt, Rusher, Tank, Stabber, EnemyFactory, bullet, etc.
- **Core Support:** `packages/core/` - Audio, BeatClock, config, mathUtils, GameState, etc.
- **Visual Effects:** `packages/fx/` - visualEffects, effects, explosions, VFXDispatcher, etc.
- **Tooling & Utilities:** `packages/tooling/` - githubIssueManager, DebugLogger, errorHandler, probes, etc.
- **API Services:** `packages/api/` - (empty after ticketing system migration)
- (See `packages/` for the complete, up-to-date modular structure. For details, see README.md.)

**Migration Complete:**
- All legacy monolithic files have been fully removed and migrated to the modular `packages/` workspace.
- The `js/` directory has been completely removed as part of the architectural migration.
- All core game logic, systems, entities, and effects now reside in the strict modular `packages/` structure.
- Do not reference, suggest, or reintroduce any monolithic or legacy patterns.
- All new code must follow the modular `packages/` architecture standards.

---

**2. Issue Tracking System: Bugs, Features, Enhancements, Tasks**

**(Migrated to GitHub Issues)**

The legacy JSON ticketing subsystem was replaced with GitHub Issues. For bug/feature tracking, labels, and automation, use the `packages/tooling/src/githubIssueManager.js` module.

If you encounter leftover code or docs referencing `TicketCore`, `/api/tickets`, or `tests/bug-reports/`, delete or migrate it immediately.

---

**3. MCP Tools Usage Guide (Summary)**

**What are MCP Tools?**
- MCP tools are advanced, server-powered utilities for memory management, Playwright testing, and file operations.
- Use them for tasks that require more power, precision, or automation than built-in Cursor tools.

**Categories & When to Use:**

- **Memory Management**
  - Use for: Reading, updating, and organizing the project's knowledge graph.
  - Key tools: `mcp_memory_read_graph`, `mcp_memory_search_nodes`, `mcp_memory_add_observations`, etc.
  - Path: N/A (entity-based, not file-based)

- **Playwright Testing**
  - Use for: Automated, probe-driven browser testing, bug reproduction, and artifact capture.
  - Key tools: `mcp_playwright_navigate`, `mcp_playwright_click`, `mcp_playwright_press_key`, etc.
  - Path: N/A (browser automation)

- **Filesystem Operations**
  - Use for: Batch file reads, precise line edits, directory management, and metadata.
  - Key tools: `mcp_filesystem_read_file`, `mcp_filesystem_edit_file`, `mcp_filesystem_list_directory`, etc.
  - Path: **Absolute paths required** (e.g., `D:\projects\vibe\...`)

**Best Practices:**
- Prefer built-in tools for simple, day-to-day edits.
- Use MCP tools for batch, advanced, or automation tasks.
- Always check path requirements (absolute for MCP filesystem, relative for built-in).
- For advanced Playwright workflows, see [MCP_PLAYWRIGHT_TESTING_GUIDE.md](./MCP_PLAYWRIGHT_TESTING_GUIDE.md).

**Example: Automated Bug Ticket Creation**
1. Run probe-driven test with MCP Playwright.
2. On failure, capture screenshot and logs.
3. Use `packages/tooling/src/githubIssueManager.js` to create a new GitHub issue with artifacts.
4. Artifacts are embedded in the GitHub issue description.

---

**Workflow Note: Robust Server Startup**
- The `predev` script kills any process on ports 5500 and 3001 before starting dev servers.
- The `dev` script starts Five Server (frontend) and waits until READY. No local Ticket API is used.
- If port 5500 is in use, Five Server will use another port (e.g., 56555); always check the console for the actual port.
- **Preferred Environment:** Windows 11 + cmd.exe + Bun for optimal performance and Windows-native tooling.

**Shell and Path Standards (MANDATORY):**
- **Default shell is cmd.exe** – NOT bash or WSL. PowerShell is optional and supported, but not the default.
- **Git hooks are implemented in `.cmd` with thin wrappers for other shells** that simply delegate to the `.cmd` scripts.
- **Use Windows-style paths** (e.g., `D:\projects\vibe`) – NOT Unix-style paths (`/c/...`).
- **Use `bun` and `bunx`** instead of `npm` and `npx`.
- **All terminal commands must run under cmd.exe**; avoid bashisms. Prefer cross-shell-friendly commands when possible.
- **File paths in scripts must use Windows format**. If using PowerShell, ensure compatibility, but default to cmd.exe semantics.
- If terminal shows `/c/...` paths, navigate to proper Windows path.
- **Ensure only ONE Bun install**: use the official installer at `%USERPROFILE%\.bun\bin`; remove Scoop/npm/Homebrew copies to avoid CLI timeouts.

---

**4. Memory Management**

- The project uses a structured knowledge graph for entities, relations, and observations.
- **Entity:** A meaningful component or concept (e.g., Player, Enemy, Bullet, BeatClock, Audio).
- **Relation:** A directed connection describing interaction or dependency (e.g., Player *fires* Bullet).
- **Observation:** A concise, factual note about an entity or relation (e.g., "`Bullet.js` handles velocity and collision detection.").

**Guidelines:**
- Keep memory focused and clean—avoid information overload.
- Quality over quantity: Fewer, well-organized entities.
- Focus on the current state; archive resolved issues.
- Regularly clean up outdated or redundant information.

**Entity Organization:**
- Max 10-15 observations per entity—split if exceeding.
- One clear responsibility per entity; use meaningful names.
- Avoid duplicates—search before creating new entities.

**Good Examples:**  
- `VibeGame` (project overview), `GameArchitecture`, `CosmicBeatSystem`, `AudioSystem`, `TestingSystem`

**Anti-Patterns to Avoid:**  
- Version-specific or temporary entities, issue-tracking entities, information overload, inconsistent naming.

**Workflow:**
1. Read memory first: `mcp_memory_read_graph`
2. Search existing: `mcp_memory_search_nodes`
3. Open specific: `mcp_memory_open_nodes`
4. Plan changes, update existing entities, add current state observations, create relations, and note key decisions.
5. Archive resolved issues, update current state, clean up temporary observations, and verify relations.

---

**5. Coding Standards**

- **MCP File Edit Workflow (MANDATORY):**  
  All `mcp_filesystem_edit_file` operations must follow this workflow:  
  1. ALWAYS use `dryRun: true` first and review the diff carefully  
  2. Only proceed with `dryRun: false` if diff matches expectations  
  3. Before real edit, back up the file if it's critical  
  4. After editing, immediately validate the file's content  
  5. If corrupted or missing expected content, restore from backup  
  6. Optionally, run a linter for code/config files  
  7. Delete backup if edit is successful

- **Simplicity:** Write simple, straightforward code.
- **Readability:** Code should be easy to read and understand.
- **Performance:** Optimize only when it doesn't harm readability.
- **Maintainability:** Code should be easy to update and maintain.
- **Testability:** Code should be easy to test.
- **Reusability:** Write reusable components and functions.

**Rules:**
- Only modify code related to the task at hand—minimal changes.
- Use early returns to avoid nested conditions.
- Prefer conditional classes over ternary operators for class attributes.
- Use descriptive names for variables and functions. Prefix event handlers with "handle" (e.g., handleClick).
- Use constants instead of functions where possible.
- Write correct, DRY (Don't Repeat Yourself) code.
- Prefer functional, immutable style unless much more verbose.
- Add a comment at the start of each function describing what it does.
- Use JSDoc comments for JavaScript (unless TypeScript).
- Order functions so that those composing others appear earlier in the file.
- If you encounter a bug or suboptimal code, add a `// TODO:` comment outlining the problem.
- All code must pass linting (ESLint) and formatting (Prettier) checks before commit. See README for setup.
- **ESLint Configuration:** Use `bunx eslint . --ext .js` for Windows compatibility instead of glob patterns
- **Linting Commands:** `bun run lint` (check), `bun run lint:fix` (auto-fix); both work in cmd.exe and PowerShell
- Use ES modules (`import`/`export`) for all new code unless otherwise specified.
- Handle errors gracefully and consistently; use early returns and clear error messages.
- Write code that is easy to test (favor pure functions, dependency injection where possible).
- Manage dependencies via `package.json` and Bun; do not add libraries without team review.

**Dependency Injection & Global Access:**
- Prefer constructor injection for dependencies (e.g., audio, cameraSystem) in new modules
- Allow window.* access for shared game systems that need global coordination
- Core systems (gameState, audio, beatClock, player) may use window.* for cross-module communication
- Entity-specific data should use dependency injection where practical
- Do not attach game state or systems to the p5 instance (`p`). Only use `p` for p5-native methods and properties.
- This hybrid approach balances modularity with practical game development needs.

**Architecture Validation:**
- New systems must receive dependencies via constructor injection where practical
- Files >500 lines should consider splitting by responsibility
- Console.log usage: Include emoji prefixes for categorization (🎮 for game state, 🎵 for audio, etc.)
- Each module should have a clear, single primary responsibility
- Update memory knowledge graph when adding new systems or major changes

**Timing Standards:**
- Use deltaTimeMs for time-based calculations (movement, animations)
- Use frame counters only for simple state machines or fixed-duration effects
- Normalize to 60fps baseline: `const dt = deltaTimeMs / 16.6667`
- BeatClock system takes precedence for musical timing coordination

**Strict Consistency Standards (Multi-AI Model Compatibility):**

- **Constructor Standards (MANDATORY):**
  - All enemy classes MUST use exact signature: `constructor(x, y, type, config, p, audio)`
  - ✅ Correct: `super(x, y, 'stabber', config, p, audio)` 
  - ❌ Incorrect: `super(x, y, 'stabber', config)` // Missing dependencies
  - 🎯 Rationale: Ensures dependency injection consistency across AI models

- **Import/Export Standards:**
  - ALWAYS import math functions from mathUtils.js instead of using p5 globals
  - ✅ Correct: `import { sin, cos, random } from './mathUtils.js'`
  - ❌ Incorrect: `sin(angle)` // Using p5 global
  - 🎯 Rationale: Explicit imports make dependencies clear and testable

- **Error Handling Standards:**
  - Pattern 1 (Preferred): `if (typeof obj !== 'undefined' && obj) { obj.method(); }`
  - Pattern 2 (External): `try { external.api(); } catch(e) { console.log('⚠️ API Error:', e); }`
  - ❌ Never: `obj.method()` // No safety checks
  - 🎯 Rationale: Consistent error handling prevents runtime crashes

- **Method Signature Standards:**
  - ALL enemy methods MUST accept deltaTimeMs parameter
  - ✅ Correct: `update(playerX, playerY, deltaTimeMs = 16.6667)`
  - ✅ Correct: `updateSpecificBehavior(playerX, playerY, deltaTimeMs)`
  - ❌ Incorrect: `update(playerX, playerY)` // Missing deltaTimeMs
  - 🎯 Rationale: Frame-independent timing requires consistent parameter passing

- **Console Logging Standards (ENFORCED):**
  - ALL logs MUST use emoji prefixes for categorization
  - ✅ Correct: `console.log('🎮 Game state changed:', newState)`
  - ✅ Correct: `console.log('🗡️ Stabber attacking at distance:', distance)`
  - ❌ Incorrect: `console.log('Stabber attacking')` // No emoji
  - Emoji map: 🎮 Game state, 🎵 Audio, 🗡️ Combat, 💥 Explosions, ⚠️ Errors, 🚀 Movement, 🎯 AI behavior, 🛡️ Defense, 🏥 Health
  - 🎯 Rationale: Consistent logging helps debugging across different developers/AI models

- **Return Value Standards:**
  - Methods that can hit targets MUST return structured objects:
  - ✅ Correct: `return { type: 'stabber-melee', playerHit: true, damage: 25 }`
  - ❌ Incorrect: `return true` // Ambiguous
  - Null/undefined for no-action cases: `return null`
  - 🎯 Rationale: Structured returns enable GameLoop.js to handle all cases consistently

- **Global Access Hierarchy (CLARIFIED):**
  - Tier 1 (window.*): gameState, audio, beatClock, player (core coordination)
  - Tier 2 (injection): p5 instance, cameraSystem, specific systems
  - Tier 3 (forbidden): Internal enemy state, temporary calculations
  - ✅ Correct: `window.audio.playSound()` // Core system
  - ✅ Correct: `this.audio.playSound()` // If injected
  - ❌ Incorrect: `window.someTemporaryVariable` // Not core system
  - 🎯 Rationale: Clear hierarchy prevents globals abuse while allowing necessary coordination

  **Event-bus requirement:** Whenever the Player instance is created or recreated, code must execute:

  ```javascript
  window.dispatchEvent(new CustomEvent('playerChanged', { detail: window.player }));
  ```

  This keeps Audio and other listening systems synchronized with the live player. Missing the dispatch is considered a breaking violation.

- **p5.js Instance Mode Standards (MANDATORY):**
  - ALL drawing functions MUST use `this.p.` or `p.` prefix in instance mode
  - ✅ Correct: `this.p.fill(255, 0, 0)`, `this.p.ellipse(x, y, w, h)`, `this.p.textAlign(this.p.CENTER)`
  - ❌ Incorrect: `fill(255, 0, 0)`, `ellipse(x, y, w, h)`, `textAlign(CENTER)` // Missing prefix
  - 🎯 Rationale: Prevents global namespace pollution and ensures instance mode compatibility across all AI models

- **Math Function Import Standards (MANDATORY):**
  - ALWAYS import math functions from mathUtils.js instead of using p5 globals
  - ✅ Correct: `import { sin, cos, random, sqrt, atan2, min, max } from './mathUtils.js'`
  - ❌ Incorrect: `sin(angle)`, `random(0, 100)`, `sqrt(x*x + y*y)` // Using p5 globals
  - 🎯 Rationale: Explicit imports make dependencies clear, enable testing, and prevent p5 version conflicts

 - **Static Guardrails (RECOMMENDED CI STEP):**
   - Run `bun run scan:consistency` locally and in CI to enforce:
     - p5 instance-mode compliance (flags unprefixed calls like `fill(`, `ellipse(`, `push()`, ...)
     - Math utilities usage (flags direct `Math.(cos|sin|atan2|sqrt|min|max)` in `packages/**`)
   - Narrow scopes:
     - Instance-mode only: `bun run scan:instance`
     - Math-only: `bun run scan:math`

- **Attack Method Return Standards (MANDATORY):**
  - ALL attack methods MUST return structured objects or null
  - ✅ Correct: `return { type: 'melee', playerHit: true, damage: 25, x: this.x, y: this.y }`
  - ✅ Correct: `return null` // No action taken
  - ❌ Incorrect: `return true`, `return false` // Ambiguous boolean returns
  - 🎯 Rationale: Structured returns enable GameLoop.js to handle all attack types consistently across AI models

- **Sound Effects Safety: All SFX names MUST be defined in `packages/core/src/audio/SoundIds.js` (`SOUND` registry) and have matching configs in `Audio.sounds`. The build will throw if mismatch.**

_See the dedicated consistency specification: [AR-consistency-standards.mdc](mdc:.cursor/rules/AR-consistency-standards.mdc) for constructor signatures, emoji logging map, p5 instance-mode rules, and other strict norms._

---

**6. Testing & Playwright**

- **Probe-driven testing only:** Manual Playwright `.spec.js` tests are **prohibited**.  Keep **probe** files only (suffix `*-probe.test.js`).  Delete or archive any remaining `.spec.js` tests.
- **Use MCP Playwright for all automated tests.**
- **Preferred automated test entry:** `bun run test:orchestrated` (pre-runs `scan:consistency` and `validate:sounds`, starts Five-Server, then runs Playwright + MCP probes deterministically).  For deterministic runs, call `setRandomSeed(1337)` (from `@vibe/core`) before starting gameplay.
- **Dev server runs on port 5500** (`http://localhost:5500`).
- **Game must be started before gameplay checks** (restart from game-over if needed).
- **Activate audio:** Click canvas at (400,300) to enable audio context.
- **Test mode:** Press 'T' key for scripted testing mode.
- **Bug report automation:** On probe failure, auto-capture screenshot and logs, restart and retry, then create a detailed bug report if the issue persists.
- **Artifacts:** Screenshots and logs are embedded in the GitHub issue description.
- **Keyboard shortcuts:** In the bug-report modal, Enter/Ctrl+Enter = Save, Escape = Cancel.
- **AI must be able to open the bug-report modal programmatically and access the same data as a human tester.**

*See linked rule file for the full probe workflow and debugging details.*

_For the full automated-testing workflow (probe conventions, dev server setup, ticket automation), see [AR-testing-and-debugging.mdc](mdc:.cursor/rules/AR-testing-and-debugging.mdc)._

---

**7. Error Handling & Fallbacks**

- **Common Issues & Solutions:**
  - *File not found:* Check current architecture, avoid legacy files.
  - *Playwright clicks fail:* Use canvas coordinates or JavaScript evaluation.
  - *Audio context issues:* Ensure user interaction before audio.
  - *Memory errors:* Check entity names exist before creating relations.
  - *Build errors:* Run terminal commands to check dependencies.

- **Fallback Strategies:**
  - If semantic search fails → try grep search with exact terms.
  - If Playwright fails → use test mode (T key) for automation.
  - If file edit fails → try reapply tool for better accuracy.
  - If memory search is empty → read the full graph to understand structure.

---

**8. Future Expansion & MCP Tools Documentation**

- For advanced MCP tool usage, troubleshooting, and workflow examples, see [MCP_TOOLS_GUIDE.md](./MCP_TOOLS_GUIDE.md).
- This file will provide:
  - Deeper explanations of each MCP tool category
  - Example commands and workflows
  - Troubleshooting tips and advanced usage
  - References to other guides (e.g., `MCP_PLAYWRIGHT_TESTING_GUIDE.md`)
- **Keep this `.cursorrules` file focused on core rules, standards, and best practices.**

---

**9. p5.js Usage**

- If a JavaScript file uses p5.js global functions (e.g., `constrain()`, `random()`, `lerp()`), add a top-of-file comment:
  `// Requires p5.js for constrain(), random(), lerp(), etc.`
- The project uses p5.js version 1.7.0. (See package.json and README.)
- In instance mode: use `p.` prefix for all p5 functions and constants (e.g., `p.TWO_PI`, `p.constrain()`)
- Import commonly used constants via mathUtils.js when possible for consistency

---

**10. HTML & CSS Standards**

- Use semantic HTML elements and follow accessibility (a11y) best practices.
- Organize CSS for modularity and maintainability (e.g., BEM, CSS modules, or utility classes).
- Place custom scripts and styles in dedicated files unless otherwise specified.
- Ensure all UI is keyboard accessible and screen-reader friendly.
- Reference the README for any framework-specific or build tool requirements.

---

**Event-Bus VFX System Rules**
- All new visual effects must use the event-bus pattern (emit events via EnemyEventBus, never call visualEffectsManager directly from entities).
- VFXDispatcher is the only module that translates gameplay events into visual/screen effects.
- All VFX must be testable via Playwright probes.
- Update effectsConfig.js for all balancing and tuning.

---

**11. Security & Secrets**

_See [AR-security.mdc](mdc:.cursor/rules/AR-security.mdc) for the authoritative security & secrets policy._

---

**End of File**