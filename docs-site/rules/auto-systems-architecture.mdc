---
description: 
globs: packages/systems/src/**,packages/game/src/GameLoop.js,packages/core/src/**
alwaysApply: false
---

# Core Systems Architecture

This document outlines the architectural principles for Vibe's core engine components, located primarily in `packages/core/` and `packages/systems/`.

## 1. The Game Loop

The `GameLoop.js` file is the heart of the game. It orchestrates the flow of updates and rendering by calling the various systems in a specific order each frame.

- **Update Phase:** Updates game state, handles input, runs AI, and resolves collisions.
- **Render Phase:** Draws the background, entities, UI, and visual effects.

When modifying a system, be mindful of its position in the game loop and how it might affect other systems.

## 2. Dependency Injection vs. Global Access

Vibe uses a hybrid approach for dependency management to balance modularity with the practical needs of game development.

- **Dependency Injection (Preferred):** For most dependencies, use constructor injection. This makes modules easier to test and reason about.
  ```javascript
  // e.g., in a new System
  constructor(cameraSystem, gameState) {
      this.cameraSystem = cameraSystem;
      this.gameState = gameState;
  }
  ```
- **Global Access (For Core Singletons):** A few core systems are managed as global singletons on the `window` object for universal access. This is reserved for systems that need to be accessed from many different, decoupled parts of the code.
  - `window.gameState`: The single source of truth for the game state.
  - `window.audio`: The global audio manager.
  - `window.beatClock`: The master timing system for rhythm-based events.
  - `window.player`: a direct reference to the player instance.

**Rule:** Do not add new globals. New systems should be injected into the classes that need them.

## 3. Stateless Systems Principle

Core systems should be as stateless as possible. They should act as "processors" that operate on the data primarily stored in `window.gameState`.

- **Rationale:** This makes the data flow predictable. State changes are centralized in `GameState`, making it easier to debug, save, and load the game in the future.

## 4. p5.js Instance Mode

All rendering logic within systems **must** use p5.js in instance mode. This means prefixing all p5 functions and constants with `this.p.` or `p.`.

- **✅ Correct:** `this.p.fill(255);`, `this.p.ellipse(100, 100, 50);`
- **❌ Incorrect:** `fill(255);`, `ellipse(100, 100, 50);`
- **Rationale:** Prevents pollution of the global namespace and is essential for reliable operation.
