# Vibe Game Design: Cosmic Beat System & Core Concepts

> **Purpose:**  
> This document explains the musical gameplay system and core design concepts.  
> For rules, see [.cursorrules](../.cursorrules).

## Cosmic Beat System Overview

Vibe is built around a unique musical timing system—the "Cosmic Beat"—which synchronizes enemy actions and player experience to a rhythmic pulse. This system creates an emergent musical experience as players interact with the game world. The frequencies of the sound-effects harmonize with eachother and are parts of a scale (we are trying A minor pentatonic at the moment).

### How the Cosmic Beat Works

- **BeatClock.js** implements the core timing logic, running at a configurable BPM (beats per minute).
- The game uses a 4/4 time signature, with each measure divided into four beats.
- Enemy actions are locked to specific beats, while the player can act freely, creating a natural musical interplay.

#### Musical Mapping

- **Player**: Shooting on 1, 2, 3 & 4 (creates a hi-hat feel)
- **Grunts**: Attack on beats 2 & 4 (snare drum)
- **Tanks**: Attack on beat 1 (bass drum)
- **Stabbers**: Attack on beat 3.5 (off-beat accent)
- **Rushers**: Can charge on any beat, but explode on strong beats (1 or 3)

This mapping ensures that gameplay actions naturally form a musical pattern, which players discover and internalize as they play.

---

## BeatClock: Technical Details

The `BeatClock` class (see `packages/core/src/BeatClock.js`) provides the following features:

- Tracks elapsed time and calculates the current beat within each measure.
- Provides methods for checking if the game is "on beat" (with a configurable tolerance window).
- Exposes specialized timing checks for each enemy type (e.g., `canGruntShoot()`, `canTankShoot()`, `canStabberAttack()`).
- Supports dynamic tempo changes and precise quarter-beat timing for advanced mechanics.

**Example Usage:**

```js
import { BeatClock } from '../packages/core/src/BeatClock.js';
const beatClock = new BeatClock(120); // 120 BPM
if (beatClock.isOnBeat([2, 4])) {
  // Grunt attacks (snare)
}
```

---

## Emergent Musical Gameplay

- The player is not forced to act on the beat, but enemy actions create a musical structure. 
- This results in a dynamic soundtrack generated by gameplay itself, blending player actions with enemy rhythms.
- The system is extensible: new enemy types or actions can be mapped to different beats or subdivisions.

### There are two ideas for how the player shooting should work at the moment, in both the player can click the mouse anytime and start shooting, but exactly what happens differ depending on which method we choose:
1. The first bullet simply waits until on beat 1, 2, 3 or 4 of the measure when the player clicks the mouse button. Player shooting is fast, so the wait will never be long. The player doesn't feel "blocked".
2. Almost the same as 1, but the first bullet comes immediately, to give a more snappy feel. If the player keeps the mouse button pressed, the rest of the bullets will automatically be fired on-beat. There has to be sensible delay from first "free" shot to the next one that will be on-beat. If for example the player fires a free shot between beat 2 and 3, the on-beat following shot shouldn't be on 3, because that would make the player shoot faster that is "allowed", so it should be on 4. On the other hand, maybe that could be made to be some feature of the game that you can fire faster if you follow this system of clicking for a free shot, waiting until a fast follow-up shot on-beat and then releasing mouse button and almost directly clicking again and so on. 

---

## References

- `BeatClock.js`: Full implementation and in-code documentation
- `GameLoop.js`: Integration of BeatClock with the main game loop
- ../README.md: Project overview and modular architecture

---

_For further details on the ticketing system, coding standards, and architecture, see the README and .cursorrules._

## Event-Bus Driven Visual Effects System

Vibe's visual feedback is now powered by a decoupled event-bus architecture:

**Flow Diagram:**
```
[Entity (e.g. Tank, Grunt)]
      │
      ▼
[EnemyEventBus.emitXYZ()]
      │
      ▼
[window.dispatchEvent(CustomEvent)]
      │
      ▼
[VFXDispatcher (central listener)]
      │
      ├──> [VisualEffectsManager] (particles, cracks, debris, sparks)
      └──> [EffectsManager] (screen shake, flash)
```

**Key Points:**
- Entities never call VFX methods directly; they emit events (`enemyHit`, `armorDamaged`, `armorBroken`, `enemyKilled`).
- `VFXDispatcher` listens for these events and triggers the appropriate visual/screen effects.
- All VFX are balanced via `effectsConfig.js` and can be throttled by `AdaptiveLODManager`.
- Procedural cracks and debris are now standard for destructible armor (e.g., Tank).
- Knock-back is applied to Grunts and can be extended to other enemies.

**Probes:**
- **Tank Armor Break Probe:** Simulates repeated hits to a tank's armor, asserts cracks and debris appear.
- **Grunt Knock-back Probe:** Simulates a bullet hit to a grunt, asserts position change (knock-back).
